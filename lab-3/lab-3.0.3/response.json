{
  "id": "436f5138-7a79-4a3c-be26-f3eb07a00fbe",
  "choices": [
    {
      "finish_reason": "stop",
      "index": 0,
      "logprobs": null,
      "message": {
        "content": "Para trabajar con **Profile-Specific Properties** en Spring Boot, puedes seguir los pasos descritos en los documentos proporcionados:\n\n### Uso de archivos `application.properties`\nPuedes crear archivos de configuración específicos para cada perfil utilizando el patrón de nombres `application-{perfil}.properties`. Estos archivos contendrán las propiedades específicas para cada perfil. Por ejemplo:\n\n- Para el perfil de **desarrollo**, crea un archivo llamado `application-development.properties` con las siguientes propiedades:\n  ```properties\n  logging.level.root=DEBUG\n  ```\n\n- Para el perfil de **producción**, crea un archivo llamado `application-production.properties` con las propiedades:\n  ```properties\n  logging.path=/var/logs/\n  logging.file=BookWorm.log\n  logging.level.root=WARN\n  ```\n\nLas propiedades comunes que no son específicas de ningún perfil pueden ser definidas en el archivo `application.properties` [doc1][doc2].\n\n### Uso de archivos `application.yml`\nSi prefieres usar `YAML` para la configuración, puedes seguir un enfoque similar creando archivos `application-{perfil}.yml` o definiendo todas las configuraciones en un único archivo `application.yml`. En este caso, puedes dividir el archivo en secciones usando `---` para cada perfil. Por ejemplo:\n\n```yaml\nlogging:\n  level:\n    root: INFO\n\n---\n\nspring:\n  profiles: development\n\nlogging:\n  level:\n    root: DEBUG\n\n---\n\nspring:\n  profiles: production\n\nlogging:\n  path: /var/logs/\n  file: BookWorm.log\n  level:\n    root: WARN\n```\n\nAquí, cada sección define las propiedades específicas de cada perfil usando el atributo `spring.profiles` [doc1][doc2].\n\n### Activación de perfiles\nPara activar un perfil específico en tu aplicación, puedes hacerlo de varias maneras:\n\n1. Pasando el perfil como argumento en la línea de comandos:\n   ```bash\n   java -jar tu-aplicacion.jar --spring.profiles.active=production\n   ```\n\n2. Definiendo el perfil en el archivo `application.yml` o `application.properties`:\n   ```yaml\n   spring:\n     profiles:\n       active: production\n   ```\n\n3. Configurando una variable de entorno que defina el perfil [doc1][doc2].\n\n### Prioridad en propiedades\nCuando defines propiedades en múltiples fuentes, Spring Boot utiliza una prioridad para determinar cuál propiedad usar. Por ejemplo, las propiedades definidas en argumentos de línea de comandos tienen mayor prioridad que las definidas en archivos de configuración. Esto asegura flexibilidad en la configuración [doc3].\n\nCon estas herramientas, puedes manejar configuraciones específicas para diferentes entornos de manera sencilla y estructurada.",
        "refusal": null,
        "role": "assistant",
        "annotations": null,
        "audio": null,
        "function_call": null,
        "tool_calls": null,
        "end_turn": true,
        "context": {
          "citations": [
            {
              "content": "this configuration will be ignored and, for lack of another overriding security configu-\nration, the auto-configured security configuration will be applied.\n\n Profiles can be activated by setting the spring.profiles.active property using\nany of the means available for setting any other configuration property. For example,\nyou could activate the “production” profile by running the application at the com-\nmand line like this:\n\n$ java -jar readinglist-0.0.1-SNAPSHOT.jar --\nspring.profiles.active=production\n\nOr you can add the spring.profiles.active property to application.yml:\n\nspring:\nprofiles:\nactive: production\n\nOr you could set an environment variable and put it in application.properties or use\nany of the other options mentioned at the beginning of section 3.2.\n\n But because Spring Boot auto-configures so much for you, it would be very incon-\nvenient to write explicit configuration just so that you can have a place to put @Profile.\n\nLicensed to Thomas Snead \n\n\n\n70 CHAPTER 3 Customizing configuration\n\nFortunately, Spring Boot supports profiles for properties set in application.properties\nand application.yml.\n\n To demonstrate profiled properties, suppose that you want a different logging con-\nfiguration in production than in development. In production, you’re only interested\nin log entries at WARN level or higher, and you want to write the log entries to a log\nfile. In development, however, you only want things logged to the console and at\nDEBUG level or higher.\n\n All you need to do is create separate configurations for each environment. How\nyou do that, however, depends on whether you’re using a properties file configuration\nor YAML configuration. \n\nWORKING WITH PROFILE-SPECIFIC PROPERTIES FILES\n\nIf you’re using application.properties to express configuration properties, you can\nprovide profile-specific properties by creating additional properties files named with\nthe pattern “application-{profile}.properties”.\n\n For the logging scenario, the development configuration would be in a file named\napplication-development.properties and contain properties for verbose, console-\nwritten logging:\n\nlogging.level.root=DEBUG\n\nBut for production, application-production.properties would configure logging to be\nat WARN level and higher and to write to a log file:\n\nlogging.path=/var/logs/\nlogging.file=BookWorm.log\nlogging.level.root=WARN\n\nMeanwhile, any properties that aren’t specific to any profile or that serve as defaults\n(in case a profile-specific configuration doesn’t specify otherwise) can continue to be\nexpressed in application.properties:\n\namazon.associateId=habuma-20\nlogging.level.root=INFO\n\nCONFIGURING WITH MULTI-PROFILE YAML FILES\n\nIf you’re using YAML for configuration properties, you can follow a similar naming\nconvention as for properties files. That is, you can create YAML files whose names fol-\nlow a pattern of “application-{profile}.yml” and continue to put non-profiled proper-\nties in application.yml.\n\n But with YAML, you also have the option of expressing configuration properties for\nall profiles in a single application.yml file. For example, the logging configuration we\nwant can be declared in application.yml like this:\n\nlogging:\nlevel:\nroot: INFO\n\nLicensed to Thomas Snead \n\n\n\n71Customizing application error pages\n\n---\n\nspring:\nprofiles: development\n\nlogging:\nlevel:\nroot: DEBUG\n\n---\n\nspring:\nprofiles: production\n\nlogging:\npath: /tmp/\nfile: BookWorm.log\nlevel:\nroot: WARN\n\nAs you can see, this application.yml file is divided into three sections by a set of tri-\nple hyphens (---). The second and third sections each specify a value for spring\n.profiles. This property indicates which profile each section’s properties apply to.\nThe properties defined in the middle section apply to development because it sets\nspring.profiles to “development”. Similarly, the last section has spring.profiles\nset to “production”, making it applicable when the “production” profile is active.\n\n The first section, on the other hand, doesn’t specify a value for spring.profiles.\n\naHR0cHM6Ly9zdG9yYWdlcmFnZmFicmlrLmJsb2IuY29yZS53aW5kb3dzLm5ldC9jb250YWluZXJwZGZzL1NwcmluZyUyMEJvb3QlMjBpbiUyMEFjdGlvbi5wZGY1",
              "title": "Spring Boot in Action.pdf",
              "url": "https://storageragfabrik.blob.core.windows.net/containerpdfs/Spring%20Boot%20in%20Action.pdf",
              "filepath": "Spring Boot in Action.pdf",
              "chunk_id": "0"
            },
            {
              "content": "this configuration will be ignored and, for lack of another overriding security configu-\nration, the auto-configured security configuration will be applied.\n\n Profiles can be activated by setting the spring.profiles.active property using\nany of the means available for setting any other configuration property. For example,\nyou could activate the “production” profile by running the application at the com-\nmand line like this:\n\n$ java -jar readinglist-0.0.1-SNAPSHOT.jar --\nspring.profiles.active=production\n\nOr you can add the spring.profiles.active property to application.yml:\n\nspring:\nprofiles:\nactive: production\n\nOr you could set an environment variable and put it in application.properties or use\nany of the other options mentioned at the beginning of section 3.2.\n\n But because Spring Boot auto-configures so much for you, it would be very incon-\nvenient to write explicit configuration just so that you can have a place to put @Profile.\n\nLicensed to Thomas Snead \n\n\n\n70 CHAPTER 3 Customizing configuration\n\nFortunately, Spring Boot supports profiles for properties set in application.properties\nand application.yml.\n\n To demonstrate profiled properties, suppose that you want a different logging con-\nfiguration in production than in development. In production, you’re only interested\nin log entries at WARN level or higher, and you want to write the log entries to a log\nfile. In development, however, you only want things logged to the console and at\nDEBUG level or higher.\n\n All you need to do is create separate configurations for each environment. How\nyou do that, however, depends on whether you’re using a properties file configuration\nor YAML configuration. \n\nWORKING WITH PROFILE-SPECIFIC PROPERTIES FILES\n\nIf you’re using application.properties to express configuration properties, you can\nprovide profile-specific properties by creating additional properties files named with\nthe pattern “application-{profile}.properties”.\n\n For the logging scenario, the development configuration would be in a file named\napplication-development.properties and contain properties for verbose, console-\nwritten logging:\n\nlogging.level.root=DEBUG\n\nBut for production, application-production.properties would configure logging to be\nat WARN level and higher and to write to a log file:\n\nlogging.path=/var/logs/\nlogging.file=BookWorm.log\nlogging.level.root=WARN\n\nMeanwhile, any properties that aren’t specific to any profile or that serve as defaults\n(in case a profile-specific configuration doesn’t specify otherwise) can continue to be\nexpressed in application.properties:\n\namazon.associateId=habuma-20\nlogging.level.root=INFO\n\nCONFIGURING WITH MULTI-PROFILE YAML FILES\n\nIf you’re using YAML for configuration properties, you can follow a similar naming\nconvention as for properties files. That is, you can create YAML files whose names fol-\nlow a pattern of “application-{profile}.yml” and continue to put non-profiled proper-\nties in application.yml.\n\n But with YAML, you also have the option of expressing configuration properties for\nall profiles in a single application.yml file. For example, the logging configuration we\nwant can be declared in application.yml like this:\n\nlogging:\nlevel:\nroot: INFO\n\nLicensed to Thomas Snead \n\n\n\n71Customizing application error pages\n\n---\n\nspring:\nprofiles: development\n\nlogging:\nlevel:\nroot: DEBUG\n\n---\n\nspring:\nprofiles: production\n\nlogging:\npath: /tmp/\nfile: BookWorm.log\nlevel:\nroot: WARN\n\nAs you can see, this application.yml file is divided into three sections by a set of tri-\nple hyphens (---). The second and third sections each specify a value for spring\n.profiles. This property indicates which profile each section’s properties apply to.\nThe properties defined in the middle section apply to development because it sets\nspring.profiles to “development”. Similarly, the last section has spring.profiles\nset to “production”, making it applicable when the “production” profile is active.\n\n The first section, on the other hand, doesn’t specify a value for spring.profiles.\n\naHR0cHM6Ly9zdG9yYWdlcmFnZmFicmlrLmJsb2IuY29yZS53aW5kb3dzLm5ldC9jb250YWluZXJwZGZzL1NwcmluZyUyMEJvb3QlMjBpbiUyMEFjdGlvbiUyMCgxKS5wZGY1",
              "title": "Spring Boot in Action (1).pdf",
              "url": "https://storageragfabrik.blob.core.windows.net/containerpdfs/Spring%20Boot%20in%20Action%20(1).pdf",
              "filepath": "Spring Boot in Action (1).pdf",
              "chunk_id": "0"
            },
            {
              "content": "ApplicationContext, configuration refers to which beans (Java\nobjects registered in Spring) have been defined to be managed by the Spring\ncontainer and are injected where needed. For example, you can define beans\nin an XML file (XML configuration), in a @Configuration class\n(Java configuration), or by relying on annotations like @Component\n(annotation-driven configuration).\n\nIn this book, unless specified otherwise, whenever I mention configuration, I\ndon’t mean the previous concept, but rather everything that’s likely to\nchange between deployments, as defined by the 15-Factor methodology.\n\nSpring provides you with a convenient Environment abstraction that\ngives you access to any configuration data, no matter its source. The two key\naspects of a Spring application environment are properties and profiles. You\nhave already worked with properties in the previous chapter. Profiles are a\ntool for labeling logical groups of beans or configuration data that should be\nloaded at runtime only if a given profile is enabled. Figure 4.2 shows the\nmain aspects of a Spring application environment.\n\n\n\nFigure 4.2 The Environment interface gives access to the two key aspects\nof any Spring application configuration: properties and profiles.\n\n\n\nThis section will cover the fundamental aspects of properties and profiles for\ncloud native applications, including how to define custom properties and\nwhen to use profiles.\n\n4.1.1 Properties: Key/value pairs for configuration\nProperties are key/value pairs supported in Java as first-class citizens with\njava.util .Properties. They play an essential role in many\napplications for storing configuration parameters outside of the compiled\nJava code. Spring Boot automatically loads them from different sources.\nWhen the same property is defined in multiple sources, there are rules that\ndetermine which one takes precedence. For example, if you specify a value\nfor the server.port property both in a property file and a command-\nline argument, the latter takes precedence over the former. The following is a\nprioritized list of some of the most common property sources, starting with\nthe highest priority:\n \n\n1. @TestPropertySource annotations on test classes\n2. Command-line arguments\n3. JVM System properties from System.getProperties()\n4. OS environment variables from System.getenv()\n5. Configuration data files\n6. @PropertySource annotations on @Configuration\n\nclasses\n7. Default properties from\nSpringApplication.setDefaultProperties\n\nFor the complete list, you can refer to the Spring Boot documentation\n(https://spring.io/projects/spring-boot).\n\nConfiguration data files can be further prioritized, starting with the highest\npriority:\n \n\nhttps://spring.io/projects/spring-boot\n\n\n1. Profile-specific application properties from application-\n{profile}.properties and application-{profile}.yml files packaged\noutside your JAR\n\n2. Application properties from application.properties and application.yml\nfiles packaged outside your JAR\n\n3. Profile-specific application properties from application-\n{profile}.properties and application-{profile}.yml files packaged inside\nyour JAR\n\n4. Application properties from application.properties and application.yml\nfiles packaged inside your JAR\n\nThe beauty of property handling in Spring is that you don’t need to know the\nspecific property source to get a value: the Environment abstraction\nlets you access any property defined in any source through a unified\ninterface. And if the same property is defined in multiple sources, it returns\nthe one with the highest priority. You can even add your own custom sources\nand assign a priority to them.\n\nNOTE Spring Framework has built-in support for properties defined according to the\nProperties format. On top of that, Spring Boot adds support for defining properties using the\nYAML format. YAML is a superset of JSON that provides more flexibility than the simpler\nProperties format. The official website describes YAML as “a human-friendly data serialization\nlanguage for all programming languages” (https://yaml.org). Feel free to choose either approach in\n\naHR0cHM6Ly9zdG9yYWdlcmFnZmFicmlrLmJsb2IuY29yZS53aW5kb3dzLm5ldC9jb250YWluZXJwZGZzL2ViaW4ucHViX2Nsb3VkLW5hdGl2ZS1zcHJpbmctaW4tYWN0aW9uLXdpdGgtc3ByaW5nLWJvb3QtYW5kLWt1YmVybmV0ZXMtMW5ic3BlZC05NzgxNjE3Mjk4NDI0JTIwKDEpLnBkZg2",
              "title": "ebin.pub_cloud-native-spring-in-action-with-spring-boot-and-kubernetes-1nbsped-9781617298424 (1).pdf",
              "url": "https://storageragfabrik.blob.core.windows.net/containerpdfs/ebin.pub_cloud-native-spring-in-action-with-spring-boot-and-kubernetes-1nbsped-9781617298424%20(1).pdf",
              "filepath": "ebin.pub_cloud-native-spring-in-action-with-spring-boot-and-kubernetes-1nbsped-9781617298424 (1).pdf",
              "chunk_id": "0"
            },
            {
              "content": "provides many useful endpoints for monitoring and managing applications in production.\n\n\n\nThe refresh event, RefreshScopeRefreshedEvent, will have no\neffect if there is no component listening. You can use the\n@RefreshScope annotation on any bean you’d like to be reloaded\nwhenever a refresh is triggered. Here’s the nice part: since you defined your\ncustom properties through a @ConfigurationProperties bean,\nit is already listening to RefreshScopeRefreshedEvent by\ndefault, so you don’t need to make any changes to your code. When a refresh\nis triggered, the PolarProperties bean will be reloaded with the\nlatest configuration available. Let’s see if it works.\n\nCHANGING CONFIGURATION AT RUNTIME\nIn this final section, I’ll show you how to change configuration at runtime.\nFirst, make sure you have both the Config Service and Catalog Service up\nand running (./gradlew bootRun). Then open the config-repo\nrepository hosting the configuration data and change the value of the\npolar.greeting property in the config-repo/ catalog-service.yml file.\n\nListing 4.21 Updating the welcome message value in the config repo\n\npolar:\n  greeting: \"Welcome to the catalog from a fresh config server\"\n\nNext, commit and push the changes.\n\nConfig Service will now return the new property value. You can check that\nby running the http :8888/catalog-service/default\ncommand. However, no signal has been sent yet to Catalog Service. If you\ntry running the http :9001/ command, you will still get the old\n“Welcome to the catalog from the config server” message. Let’s trigger a\nrefresh.\n\nGo ahead and send a POST request to the Catalog Service application at the\n/actuator/refresh endpoint:\n\n$ http POST :9001/actuator/refresh\n\n\n\nThis request will trigger a RefreshScopeRefreshedEvent\nevent. The PolarProperties bean, because it’s annotated with\n@ConfigurationProperties, will react to the event and read the\nnew configuration data. Let’s verify that:\n\n$ http :9001/\nWelcome to the catalog from a fresh config server\n\nFinally, stop the execution of both applications with Ctrl-C.\n\nGood job! You have just updated the configuration of an application at\nruntime without restarting it, without rebuilding the application, and\nensuring the traceability of changes. It’s perfect for the cloud. In chapter 14,\nyou’ll learn more advanced techniques for managing configuration that\nyou’ll need in production, including secrets management, ConfigMaps, and\nSecrets.\n\nSummary\n \n\nThe Spring Environment abstraction provides a unified interface\nfor accessing properties and profiles.\nProperties are key/value pairs used to store configuration.\nProfiles are logical groups of beans registered only when a specific\nprofile is active.\nSpring Boot collects properties from different sources according to\nprecedence rules. From the highest to the lowest precedence, properties\ncan be defined in command-line arguments, JVM system variables, OS\nenvironment variables, profile-specific property files, and generic\nproperty files.\nSpring beans can access properties from the Environment object\nby injecting the value with the @Value annotation, or from a bean\nmapped to a set of properties with the\n@ConfigurationProperties annotation.\n\n\n\nThe active profiles can be defined with the\nspring.profiles.active property.\nThe @Profile annotation marks beans or configuration classes to\nbe considered only when the specified profile is active.\nProperties, as managed in Spring Boot, provide externalized\nconfiguration as defined by the 15-Factor methodology, but that’s not\nenough.\nA configuration server handles aspects like secret encryption,\nconfiguration traceability, versioning, and context refreshing at runtime\nwith no restart.\nA configuration server can be set up with the Spring Cloud Config\nServer library.\nThe configuration itself can be stored according to different strategies,\nsuch as in a dedicated Git repository.\nThe config server uses the application name, active profiles, and Git-\nspecific labels to identify which configuration should be provided to\nwhich application.\n\naHR0cHM6Ly9zdG9yYWdlcmFnZmFicmlrLmJsb2IuY29yZS53aW5kb3dzLm5ldC9jb250YWluZXJwZGZzL2ViaW4ucHViX2Nsb3VkLW5hdGl2ZS1zcHJpbmctaW4tYWN0aW9uLXdpdGgtc3ByaW5nLWJvb3QtYW5kLWt1YmVybmV0ZXMtMW5ic3BlZC05NzgxNjE3Mjk4NDI0JTIwKDEpLnBkZg2",
              "title": "ebin.pub_cloud-native-spring-in-action-with-spring-boot-and-kubernetes-1nbsped-9781617298424 (1).pdf",
              "url": "https://storageragfabrik.blob.core.windows.net/containerpdfs/ebin.pub_cloud-native-spring-in-action-with-spring-boot-and-kubernetes-1nbsped-9781617298424%20(1).pdf",
              "filepath": "ebin.pub_cloud-native-spring-in-action-with-spring-boot-and-kubernetes-1nbsped-9781617298424 (1).pdf",
              "chunk_id": "1"
            },
            {
              "content": "provides many useful endpoints for monitoring and managing applications in production.\n\n\n\nThe refresh event, RefreshScopeRefreshedEvent, will have no\neffect if there is no component listening. You can use the\n@RefreshScope annotation on any bean you’d like to be reloaded\nwhenever a refresh is triggered. Here’s the nice part: since you defined your\ncustom properties through a @ConfigurationProperties bean,\nit is already listening to RefreshScopeRefreshedEvent by\ndefault, so you don’t need to make any changes to your code. When a refresh\nis triggered, the PolarProperties bean will be reloaded with the\nlatest configuration available. Let’s see if it works.\n\nCHANGING CONFIGURATION AT RUNTIME\nIn this final section, I’ll show you how to change configuration at runtime.\nFirst, make sure you have both the Config Service and Catalog Service up\nand running (./gradlew bootRun). Then open the config-repo\nrepository hosting the configuration data and change the value of the\npolar.greeting property in the config-repo/ catalog-service.yml file.\n\nListing 4.21 Updating the welcome message value in the config repo\n\npolar:\n  greeting: \"Welcome to the catalog from a fresh config server\"\n\nNext, commit and push the changes.\n\nConfig Service will now return the new property value. You can check that\nby running the http :8888/catalog-service/default\ncommand. However, no signal has been sent yet to Catalog Service. If you\ntry running the http :9001/ command, you will still get the old\n“Welcome to the catalog from the config server” message. Let’s trigger a\nrefresh.\n\nGo ahead and send a POST request to the Catalog Service application at the\n/actuator/refresh endpoint:\n\n$ http POST :9001/actuator/refresh\n\n\n\nThis request will trigger a RefreshScopeRefreshedEvent\nevent. The PolarProperties bean, because it’s annotated with\n@ConfigurationProperties, will react to the event and read the\nnew configuration data. Let’s verify that:\n\n$ http :9001/\nWelcome to the catalog from a fresh config server\n\nFinally, stop the execution of both applications with Ctrl-C.\n\nGood job! You have just updated the configuration of an application at\nruntime without restarting it, without rebuilding the application, and\nensuring the traceability of changes. It’s perfect for the cloud. In chapter 14,\nyou’ll learn more advanced techniques for managing configuration that\nyou’ll need in production, including secrets management, ConfigMaps, and\nSecrets.\n\nSummary\n \n\nThe Spring Environment abstraction provides a unified interface\nfor accessing properties and profiles.\nProperties are key/value pairs used to store configuration.\nProfiles are logical groups of beans registered only when a specific\nprofile is active.\nSpring Boot collects properties from different sources according to\nprecedence rules. From the highest to the lowest precedence, properties\ncan be defined in command-line arguments, JVM system variables, OS\nenvironment variables, profile-specific property files, and generic\nproperty files.\nSpring beans can access properties from the Environment object\nby injecting the value with the @Value annotation, or from a bean\nmapped to a set of properties with the\n@ConfigurationProperties annotation.\n\n\n\nThe active profiles can be defined with the\nspring.profiles.active property.\nThe @Profile annotation marks beans or configuration classes to\nbe considered only when the specified profile is active.\nProperties, as managed in Spring Boot, provide externalized\nconfiguration as defined by the 15-Factor methodology, but that’s not\nenough.\nA configuration server handles aspects like secret encryption,\nconfiguration traceability, versioning, and context refreshing at runtime\nwith no restart.\nA configuration server can be set up with the Spring Cloud Config\nServer library.\nThe configuration itself can be stored according to different strategies,\nsuch as in a dedicated Git repository.\nThe config server uses the application name, active profiles, and Git-\nspecific labels to identify which configuration should be provided to\nwhich application.\n\naHR0cHM6Ly9zdG9yYWdlcmFnZmFicmlrLmJsb2IuY29yZS53aW5kb3dzLm5ldC9jb250YWluZXJwZGZzL2ViaW4ucHViX2Nsb3VkLW5hdGl2ZS1zcHJpbmctaW4tYWN0aW9uLXdpdGgtc3ByaW5nLWJvb3QtYW5kLWt1YmVybmV0ZXMtMW5ic3BlZC05NzgxNjE3Mjk4NDI0LnBkZg2",
              "title": "ebin.pub_cloud-native-spring-in-action-with-spring-boot-and-kubernetes-1nbsped-9781617298424.pdf",
              "url": "https://storageragfabrik.blob.core.windows.net/containerpdfs/ebin.pub_cloud-native-spring-in-action-with-spring-boot-and-kubernetes-1nbsped-9781617298424.pdf",
              "filepath": "ebin.pub_cloud-native-spring-in-action-with-spring-boot-and-kubernetes-1nbsped-9781617298424.pdf",
              "chunk_id": "0"
            }
          ],
          "intent": "[\"Cómo trabajar con las propiedades específicas de perfil (PROFILE-SPECIFIC PROPERTIES)\"]"
        }
      }
    }
  ],
  "created": 1747277128,
  "model": "gpt-4o",
  "object": "extensions.chat.completion",
  "service_tier": null,
  "system_fingerprint": "fp_ee1d74bde0",
  "usage": {
    "completion_tokens": 569,
    "prompt_tokens": 7002,
    "total_tokens": 7571,
    "completion_tokens_details": null,
    "prompt_tokens_details": null
  }
}